#define FASTLED_ESP32_I2S true // keeps esp from crashing when using FastLED and wifi at the same time
#include <Arduino.h>
#include <FastLED.h>
#include "SPIFFS.h"

#include "modules/twinkle.h"
#include "modules/ocean.h"
//#include "modules/music_visualisation.h"
#include "modules/user_interface.h"
#include "modules/dmx_manager.h"
#include "led_config.h"
#include "main.h"
#include "tools/filters.h"
#include "tools/loop_timer.h"
#include "main_project_utils.h"
#include "github_update.h"
#include "memory_module.h"
#include "ram_log.h"



// ------------------ SYSTEM -------------------- //

TaskHandle_t Task_network;

void loop_core_0(void* parameter) {
    for(;;) {
        // run wifi update routine
        project_utils_update();
        ui_serial_comm_handler();
        dmx_listen();
        vTaskDelay(10 / portTICK_PERIOD_MS);
    }
}

MemoryModule control_settings;

// --------------- LED VARIABLES ---------------- //

// declare memory for the led colors
LED_MUSHROOMS_SET_t led_array_set_real;         // contains the values that get send to the leds
LED_MUSHROOMS_SET_t led_array_set_current;      // contains the values generated by the current module
LED_MUSHROOMS_SET_t led_array_set_previous;         // contains the values of the next module in line

uint8_t blend_opacity = 0;
uint8_t module_index_current = 2;
uint8_t module_index_previous = 2;

#define EFFECT_MODULE_NUM                     3

void animations_update(LED_MUSHROOMS_SET_t *set) {
    twinkle_update(reinterpret_cast<CRGBSet &>(*reinterpret_cast<CRGB *>(&set->leds_largeshrooms_left)));
    twinkle_update(reinterpret_cast<CRGBSet &>(*reinterpret_cast<CRGB *>(&set->leds_largeshrooms_right)));
    ocean_update(reinterpret_cast<CRGBSet &>(*reinterpret_cast<CRGB *>(&set->leds_whiteshrooms)));
    twinkle_update(reinterpret_cast<CRGBSet &>(*reinterpret_cast<CRGB *>(&set->leds_redshrooms_left)));
    twinkle_update(reinterpret_cast<CRGBSet &>(*reinterpret_cast<CRGB *>(&set->leds_redshrooms_right)));
}

void blackout_update(LED_MUSHROOMS_SET_t *set) {
    set->leds_redshrooms_left = CRGB::Black;
    set->leds_largeshrooms_right = CRGB::Black;
    set->leds_whiteshrooms = CRGB::Black;
    set->leds_redshrooms_left = CRGB::Black;
    set->leds_redshrooms_right = CRGB::Black;
}

// holds effects that program will cycle through
void (*module_update[EFFECT_MODULE_NUM])(LED_MUSHROOMS_SET_t *set) = {
        blackout_update,
        music_vis_update,
        animations_update,
};

void led_mode_switch(uint8_t module_index) {
    led_array_set_previous = led_array_set_current;
    blackout_update(&led_array_set_current);
    module_index_previous = module_index_current;
    module_index_current = module_index;
    blend_opacity = 0;
}



// ---------------- WEB CONTROL ------------------ //

void webfct_control_serve(AsyncWebServerRequest *request) {
    request->send(SPIFFS, "/control.html", "text/html");
}

void webfct_control_get(AsyncWebServerRequest *request){
    if (request->hasParam("musicMode")) {
        control_settings.set("musicMode", request->getParam("musicMode")->value().equals("true"), true);
        
        if (*control_settings.getBool("musicMode"))
            led_mode_switch(MODE_MUSIC);

        else led_mode_switch(MODE_AMBIENT);
    }

    request->send(200, "text/plain", "OK");
}

void webfct_get_musicMode(AsyncWebServerRequest *request) {
    String payload = String(*control_settings.getBool("musicMode")) + "\n";
    request->send(200, "text/plain", payload);
}



// ---------------- MAIN SETUP ------------------- //

void setup() {

    // ---------- system ----------- //
    delay(500);
    DualSerial.begin(115200);

    control_settings.addParameter("musicMode", false);
    control_settings.loadAll();

    // --------  led setup --------- //

    // initialize effect modules
    twinkle_init();
    music_vis_init();
    //dmx_init();

    //start up FastLED object
    FastLED.addLeds<LED_TYPE, LED_PIN_BASS_1, COLOR_ORDER>(led_array_set_real.leds_largeshrooms_left,
                                                           LED_NUM_BASS_1).setCorrection(
                                                            TypicalLEDStrip);
    FastLED.addLeds<LED_TYPE, LED_PIN_BASS_2, COLOR_ORDER>(led_array_set_real.leds_largeshrooms_right,
                                                           LED_NUM_BASS_2).setCorrection(
                                                            TypicalLEDStrip);
    FastLED.addLeds<LED_TYPE, LED_PIN_MID, COLOR_ORDER>(led_array_set_real.leds_whiteshrooms,
                                                        LED_NUM_MID).setCorrection(TypicalLEDStrip);
    FastLED.addLeds<LED_TYPE, LED_PIN_TREBLE_1, COLOR_ORDER>(led_array_set_real.leds_redshrooms_left,
                                                             LED_NUM_TREBLE_1).setCorrection(
                                                                     TypicalLEDStrip);
    FastLED.addLeds<LED_TYPE, LED_PIN_TREBLE_2, COLOR_ORDER>(led_array_set_real.leds_redshrooms_right,
                                                             LED_NUM_TREBLE_2).setCorrection(
                                                                     TypicalLEDStrip);

    // set all leds to black
    blackout_update(&led_array_set_real);
    FastLED.show();

    if (*control_settings.getBool("musicMode"))
        led_mode_switch(MODE_MUSIC);

    else led_mode_switch(MODE_AMBIENT);

    //led_mode_switch(MODE_DMX);

    // --------- network ---------- //

    uint8_t retval;

    DualSerial.println("Starting Wifi...");
    project_utils_init("Magic Light Organ");

    server.on("/control/musicmode", HTTP_GET, webfct_get_musicMode);
    server.on("/control/toggle", HTTP_GET, webfct_control_get); 
    server.on("/control", HTTP_GET, webfct_control_serve);

    // ------- task setup --------- // 
    
    //everything network related will run on core 0, this will start the task
    xTaskCreatePinnedToCore(
        loop_core_0,
        "Task_network",
        8192,
        NULL,
        1,
        &Task_network,
        0);

    delay(2000);
}


void loop() {
    // ---------- system ----------- //

    // save t_0 time stamp in loop_timer
    t_0 = micros();


    // ----------- leds ------------ //

    if (blend_opacity < 255) {
        module_update[module_index_previous](&led_array_set_previous);
        module_update[module_index_current](&led_array_set_current);

        blend(led_array_set_previous.leds_largeshrooms_left, led_array_set_current.leds_largeshrooms_left,
            led_array_set_real.leds_largeshrooms_left, LED_NUM_BASS_1, blend_opacity);
        blend(led_array_set_previous.leds_largeshrooms_right, led_array_set_current.leds_largeshrooms_right,
            led_array_set_real.leds_largeshrooms_right, LED_NUM_BASS_2, blend_opacity);
        blend(led_array_set_previous.leds_whiteshrooms, led_array_set_current.leds_whiteshrooms,
            led_array_set_real.leds_whiteshrooms, LED_NUM_MID, blend_opacity);
        blend(led_array_set_previous.leds_redshrooms_left, led_array_set_current.leds_redshrooms_left,
            led_array_set_real.leds_redshrooms_left, LED_NUM_TREBLE_1, blend_opacity);
        blend(led_array_set_previous.leds_redshrooms_right, led_array_set_current.leds_redshrooms_right,
            led_array_set_real.leds_redshrooms_right, LED_NUM_TREBLE_2, blend_opacity);

        blend_opacity++;
    }

    else module_update[module_index_current](&led_array_set_real);

    // execute led colors
    FastLED.show();


    // ---------- system ----------- //

    loop_timer++;

#ifdef DEBUG_DISPLAY_LOOP_FRQ
    EVERY_N_SECONDS (5) {
        // calculate the loop time and print. serial comm only decreases loop freq when serial.print is called
        DualSerial.print("loop freq in Hz: ");
        DualSerial.println(loop_timer_get_loop_freq());
    }
#endif

#ifdef SYSCTRL_LOOPTIMER
    // keep loop at constant cycle frequency
    loop_timer_check_cycle_freq();
#endif
}
    
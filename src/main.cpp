#include <Arduino.h>
#include <FastLED.h>
#include "modules/twinkle.h"
#include "modules/ocean.h"
#include "modules/music_visualisation.h"
#include "led_config.h"

#include "tools/filters.h"
#include "tools/loop_timer.h"
#include "wifilight.h"
#include "wifi_handler.h"
#include "../lib/common_lib_wifi_debugger/src/wifi_handler.h"

// debug and system control options
#define DEBUG_DISPLAY_LOOP_FRQ          // use this to output the loop freq in hz via serial print
#define SYSCTRL_LOOPTIMER               // enable loop frequency control, remember to also set the loop freq in the loop_timer.h

// create the FastLED array containing led colors

// declare a bunch of memory for the led colours
LED_MUSHROOMS_SET_t led_array_set_real;         // this one contains the values that get send to the leds
LED_MUSHROOMS_SET_t led_array_set_current;      // this here will contain the values generated by the current module
LED_MUSHROOMS_SET_t led_array_set_next;         // and this one will contain the values of the next module



bool state_machine_ambient_flag = false;

uint8_t blend_opacity = 255;
uint8_t module_index_next;
uint8_t module_index_current;

#define EFFECT_MODULE_NUM                     3

void animations_update(LED_MUSHROOMS_SET_t *set) {
    twinkle_update(reinterpret_cast<CRGBSet &>(*reinterpret_cast<CRGB *>(&set->leds_largeshrooms_left)));
    twinkle_update(reinterpret_cast<CRGBSet &>(*reinterpret_cast<CRGB *>(&set->leds_largeshrooms_right)));
    ocean_update(reinterpret_cast<CRGBSet &>(*reinterpret_cast<CRGB *>(&set->leds_whiteshrooms)));
    twinkle_update(reinterpret_cast<CRGBSet &>(*reinterpret_cast<CRGB *>(&set->leds_redshrooms_left)));
    twinkle_update(reinterpret_cast<CRGBSet &>(*reinterpret_cast<CRGB *>(&set->leds_redshrooms_right)));
}

void blackout_update(LED_MUSHROOMS_SET_t *set) {
    set->leds_redshrooms_left = CRGB::Black;
    set->leds_largeshrooms_right = CRGB::Black;
    set->leds_whiteshrooms = CRGB::Black;
    set->leds_redshrooms_left = CRGB::Black;
    set->leds_redshrooms_right = CRGB::Black;
}

void (*module_update[EFFECT_MODULE_NUM])(LED_MUSHROOMS_SET_t *set) = {
        animations_update,
        music_vis_update,
        blackout_update
};

void setup() {
    // initialize serial communication
    Serial.begin(115200);

    // initialize effect modules
    twinkle_init();
    music_vis_init();

    //start up FastLED object
    FastLED.addLeds<LED_TYPE, LED_PIN_BASS_1, COLOR_ORDER>(led_array_set_real.leds_largeshrooms_left,
                                                           LED_NUM_BASS_1).setCorrection(
                                                            TypicalLEDStrip);
    FastLED.addLeds<LED_TYPE, LED_PIN_BASS_2, COLOR_ORDER>(led_array_set_real.leds_largeshrooms_right,
                                                           LED_NUM_BASS_2).setCorrection(
                                                            TypicalLEDStrip);
    FastLED.addLeds<LED_TYPE, LED_PIN_MID, COLOR_ORDER>(led_array_set_real.leds_whiteshrooms,
                                                        LED_NUM_MID).setCorrection(TypicalLEDStrip);
    FastLED.addLeds<LED_TYPE, LED_PIN_TREBLE_1, COLOR_ORDER>(led_array_set_real.leds_redshrooms_left,
                                                             LED_NUM_TREBLE_1).setCorrection(
                                                                     TypicalLEDStrip);
    FastLED.addLeds<LED_TYPE, LED_PIN_TREBLE_2, COLOR_ORDER>(led_array_set_real.leds_redshrooms_right,
                                                             LED_NUM_TREBLE_2).setCorrection(
                                                                     TypicalLEDStrip);

    // init wifi module
    wifilight_init(led_array_set_real.leds_whiteshrooms);
    wifi_handler_init("Free WiFi2.4", "IschMirDochGlich1", );
}


void loop() {
    // save t_0 time stamp in loop_timer
    t_0 = micros();

    // run wifi update routine
    wifilight_update();
    wifi_handler_update();


    module_update[module_index_next](&led_array_set_next);
    module_update[module_index_current](&led_array_set_current);


    blend(led_array_set_current.leds_largeshrooms_left, led_array_set_next.leds_largeshrooms_left,
          led_array_set_real.leds_largeshrooms_left, LED_NUM_BASS_1,
          blend_opacity);
    blend(led_array_set_current.leds_largeshrooms_right, led_array_set_next.leds_largeshrooms_right,
          led_array_set_real.leds_largeshrooms_right, LED_NUM_BASS_2,
          blend_opacity);
    blend(led_array_set_current.leds_whiteshrooms, led_array_set_next.leds_whiteshrooms,
          led_array_set_real.leds_whiteshrooms, LED_NUM_MID,
          blend_opacity);
    blend(led_array_set_current.leds_redshrooms_left, led_array_set_next.leds_redshrooms_left,
          led_array_set_real.leds_redshrooms_left, LED_NUM_TREBLE_1,
          blend_opacity);
    blend(led_array_set_current.leds_redshrooms_right, led_array_set_next.leds_redshrooms_right,
          led_array_set_real.leds_redshrooms_right, LED_NUM_TREBLE_2,
          blend_opacity);

    module_update[module_index_current](&led_array_set_real);

    if (blend_opacity <= 254) {
        blend_opacity++;
    }

    Serial.println(module_index_next);

    // state machine
    if (!lights[0].lightState && !lights[1].lightState) {
        // reset opacity if this is a new module
        if (module_index_next != 2)
            blend_opacity = 0;
        // both modes off, so queue black color module
        module_index_current = module_index_next;
        module_index_next = 2;

        state_machine_ambient_flag = false; // mark ambient light mode as default
    }
    else if (lights[0].lightState && !lights[1].lightState) {
        // reset opacity if this is a new module
        if (module_index_next != 1)
            blend_opacity = 0;

        // light organ active
        module_index_current = module_index_next;
        module_index_next = 1;

        state_machine_ambient_flag = false; // mark current state
    }
    else if (!lights[0].lightState && lights[1].lightState) {
        // reset opacity if this is a new module
        if (module_index_next != 0)
            blend_opacity = 0;

        // ambient light active
        module_index_current = module_index_next;
        module_index_next = 0;

        state_machine_ambient_flag = true; // mark current state
    }
    else {
        // both modes have been activated
        if (!state_machine_ambient_flag)
            // ambient light has been activated while light organ was still on
            lights[0].lightState = false;   // turn off light organ

        else
            // light organ has been activated while ambient was still on
            lights[1].lightState = false;   // turn off ambient
    }

    // execute led colors
    FastLED.show();

    loop_timer++;

#ifdef DEBUG_DISPLAY_LOOP_FRQ
    EVERY_N_SECONDS (5) {
        // calculate the loop time and print. serial comm only decreases loop freq when serial.print is called
        Serial.print("loop freq in Hz: ");
        Serial.println(loop_timer_get_loop_freq());
    }
#endif

#ifdef SYSCTRL_LOOPTIMER
    // keep loop at constant cycle frequency
    loop_timer_check_cycle_freq();
#endif

}
    